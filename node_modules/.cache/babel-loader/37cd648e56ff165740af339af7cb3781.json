{"ast":null,"code":"'use client';\n\nimport _slicedToArray from \"D:\\\\MOZZHUB-ReactJS\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport { unstable_useForkRef as useForkRef } from '@mui/utils';\nimport { ListActionTypes } from './listActions.types';\nimport { listReducer as defaultReducer } from './listReducer';\nimport { useControllableReducer } from '../utils/useControllableReducer';\nimport { areArraysEqual } from '../utils/areArraysEqual';\nimport { useTextNavigation } from '../utils/useTextNavigation';\nimport { extractEventHandlers } from '../utils/extractEventHandlers';\nvar EMPTY_OBJECT = {};\n\nvar NOOP = function NOOP() {};\n\nvar defaultItemComparer = function defaultItemComparer(optionA, optionB) {\n  return optionA === optionB;\n};\n\nvar defaultIsItemDisabled = function defaultIsItemDisabled() {\n  return false;\n};\n\nvar defaultItemStringifier = function defaultItemStringifier(item) {\n  return typeof item === 'string' ? item : String(item);\n};\n\nvar defaultGetInitialState = function defaultGetInitialState() {\n  return {\n    highlightedValue: null,\n    selectedValues: []\n  };\n};\n/**\n * The useList is a lower-level utility that is used to build list-like components.\n * It's used to manage the state of the list and its items.\n *\n * Supports highlighting a single item and selecting an arbitrary number of items.\n *\n * The state of the list is managed by a controllable reducer - that is a reducer that can have its state\n * controlled from outside.\n *\n * By default, the state consists of `selectedValues` and `highlightedValue` but can be extended by the caller of the hook.\n * Also the actions that can be dispatched and the reducer function can be defined externally.\n *\n * @template ItemValue The type of the item values.\n * @template State The type of the list state. This should be a subtype of `ListState<ItemValue>`.\n * @template CustomAction The type of the actions that can be dispatched (besides the standard ListAction).\n * @template CustomActionContext The shape of additional properties that will be added to actions when dispatched.\n *\n * @ignore - internal hook.\n */\n\n\nfunction useList(params) {\n  var _params$controlledPro = params.controlledProps,\n      controlledProps = _params$controlledPro === void 0 ? EMPTY_OBJECT : _params$controlledPro,\n      _params$disabledItems = params.disabledItemsFocusable,\n      disabledItemsFocusable = _params$disabledItems === void 0 ? false : _params$disabledItems,\n      _params$disableListWr = params.disableListWrap,\n      disableListWrap = _params$disableListWr === void 0 ? false : _params$disableListWr,\n      _params$focusManageme = params.focusManagement,\n      focusManagement = _params$focusManageme === void 0 ? 'activeDescendant' : _params$focusManageme,\n      _params$getInitialSta = params.getInitialState,\n      getInitialState = _params$getInitialSta === void 0 ? defaultGetInitialState : _params$getInitialSta,\n      getItemDomElement = params.getItemDomElement,\n      getItemId = params.getItemId,\n      _params$isItemDisable = params.isItemDisabled,\n      isItemDisabled = _params$isItemDisable === void 0 ? defaultIsItemDisabled : _params$isItemDisable,\n      externalListRef = params.rootRef,\n      _params$onStateChange = params.onStateChange,\n      onStateChange = _params$onStateChange === void 0 ? NOOP : _params$onStateChange,\n      items = params.items,\n      _params$itemComparer = params.itemComparer,\n      itemComparer = _params$itemComparer === void 0 ? defaultItemComparer : _params$itemComparer,\n      _params$getItemAsStri = params.getItemAsString,\n      getItemAsString = _params$getItemAsStri === void 0 ? defaultItemStringifier : _params$getItemAsStri,\n      onChange = params.onChange,\n      onHighlightChange = params.onHighlightChange,\n      onItemsChange = params.onItemsChange,\n      _params$orientation = params.orientation,\n      orientation = _params$orientation === void 0 ? 'vertical' : _params$orientation,\n      _params$pageSize = params.pageSize,\n      pageSize = _params$pageSize === void 0 ? 5 : _params$pageSize,\n      _params$reducerAction = params.reducerActionContext,\n      reducerActionContext = _params$reducerAction === void 0 ? EMPTY_OBJECT : _params$reducerAction,\n      _params$selectionMode = params.selectionMode,\n      selectionMode = _params$selectionMode === void 0 ? 'single' : _params$selectionMode,\n      externalReducer = params.stateReducer,\n      _params$componentName = params.componentName,\n      componentName = _params$componentName === void 0 ? 'useList' : _params$componentName;\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (focusManagement === 'DOM' && getItemDomElement == null) {\n      throw new Error('useList: The `getItemDomElement` prop is required when using the `DOM` focus management.');\n    }\n\n    if (focusManagement === 'activeDescendant' && getItemId == null) {\n      throw new Error('useList: The `getItemId` prop is required when using the `activeDescendant` focus management.');\n    }\n  }\n\n  var listRef = React.useRef(null);\n  var handleRef = useForkRef(externalListRef, listRef);\n  var handleHighlightChange = React.useCallback(function (event, value, reason) {\n    onHighlightChange == null || onHighlightChange(event, value, reason);\n\n    if (focusManagement === 'DOM' && value != null && (reason === ListActionTypes.itemClick || reason === ListActionTypes.keyDown || reason === ListActionTypes.textNavigation)) {\n      var _getItemDomElement;\n\n      getItemDomElement == null || (_getItemDomElement = getItemDomElement(value)) == null || _getItemDomElement.focus();\n    }\n  }, [getItemDomElement, onHighlightChange, focusManagement]);\n  var stateComparers = React.useMemo(function () {\n    return {\n      highlightedValue: itemComparer,\n      selectedValues: function selectedValues(valuesArray1, valuesArray2) {\n        return areArraysEqual(valuesArray1, valuesArray2, itemComparer);\n      }\n    };\n  }, [itemComparer]); // This gets called whenever a reducer changes the state.\n\n  var handleStateChange = React.useCallback(function (event, field, value, reason, state) {\n    onStateChange == null || onStateChange(event, field, value, reason, state);\n\n    switch (field) {\n      case 'highlightedValue':\n        handleHighlightChange(event, value, reason);\n        break;\n\n      case 'selectedValues':\n        onChange == null || onChange(event, value, reason);\n        break;\n\n      default:\n        break;\n    }\n  }, [handleHighlightChange, onChange, onStateChange]); // The following object is added to each action when it's dispatched.\n  // It's accessible in the reducer via the `action.context` field.\n\n  var listActionContext = React.useMemo(function () {\n    return {\n      disabledItemsFocusable: disabledItemsFocusable,\n      disableListWrap: disableListWrap,\n      focusManagement: focusManagement,\n      isItemDisabled: isItemDisabled,\n      itemComparer: itemComparer,\n      items: items,\n      getItemAsString: getItemAsString,\n      onHighlightChange: handleHighlightChange,\n      orientation: orientation,\n      pageSize: pageSize,\n      selectionMode: selectionMode,\n      stateComparers: stateComparers\n    };\n  }, [disabledItemsFocusable, disableListWrap, focusManagement, isItemDisabled, itemComparer, items, getItemAsString, handleHighlightChange, orientation, pageSize, selectionMode, stateComparers]);\n  var initialState = getInitialState();\n  var reducer = externalReducer != null ? externalReducer : defaultReducer;\n  var actionContext = React.useMemo(function () {\n    return _extends({}, reducerActionContext, listActionContext);\n  }, [reducerActionContext, listActionContext]);\n\n  var _useControllableReduc = useControllableReducer({\n    reducer: reducer,\n    actionContext: actionContext,\n    initialState: initialState,\n    controlledProps: controlledProps,\n    stateComparers: stateComparers,\n    onStateChange: handleStateChange,\n    componentName: componentName\n  }),\n      _useControllableReduc2 = _slicedToArray(_useControllableReduc, 2),\n      state = _useControllableReduc2[0],\n      dispatch = _useControllableReduc2[1];\n\n  var highlightedValue = state.highlightedValue,\n      selectedValues = state.selectedValues;\n  var handleTextNavigation = useTextNavigation(function (searchString, event) {\n    return dispatch({\n      type: ListActionTypes.textNavigation,\n      event: event,\n      searchString: searchString\n    });\n  });\n  var previousItems = React.useRef([]);\n  React.useEffect(function () {\n    // Whenever the `items` object changes, we need to determine if the actual items changed.\n    // If they did, we need to dispatch an `itemsChange` action, so the selected/highlighted state is updated.\n    if (areArraysEqual(previousItems.current, items, itemComparer)) {\n      return;\n    }\n\n    dispatch({\n      type: ListActionTypes.itemsChange,\n      event: null,\n      items: items,\n      previousItems: previousItems.current\n    });\n    previousItems.current = items;\n    onItemsChange == null || onItemsChange(items);\n  }, [items, itemComparer, dispatch, onItemsChange]);\n\n  var createHandleKeyDown = function createHandleKeyDown(externalHandlers) {\n    return function (event) {\n      var _externalHandlers$onK;\n\n      (_externalHandlers$onK = externalHandlers.onKeyDown) == null || _externalHandlers$onK.call(externalHandlers, event);\n\n      if (event.defaultMuiPrevented) {\n        return;\n      }\n\n      var keysToPreventDefault = ['Home', 'End', 'PageUp', 'PageDown'];\n\n      if (orientation === 'vertical') {\n        keysToPreventDefault.push('ArrowUp', 'ArrowDown');\n      } else {\n        keysToPreventDefault.push('ArrowLeft', 'ArrowRight');\n      }\n\n      if (focusManagement === 'activeDescendant') {\n        // When the child element is focused using the activeDescendant attribute,\n        // the list handles keyboard events on its behalf.\n        // We have to `preventDefault()` is this case to prevent the browser from\n        // scrolling the view when space is pressed or submitting forms when enter is pressed.\n        keysToPreventDefault.push(' ', 'Enter');\n      }\n\n      if (keysToPreventDefault.includes(event.key)) {\n        event.preventDefault();\n      }\n\n      dispatch({\n        type: ListActionTypes.keyDown,\n        key: event.key,\n        event: event\n      });\n      handleTextNavigation(event);\n    };\n  };\n\n  var createHandleBlur = function createHandleBlur(externalHandlers) {\n    return function (event) {\n      var _externalHandlers$onB, _listRef$current;\n\n      (_externalHandlers$onB = externalHandlers.onBlur) == null || _externalHandlers$onB.call(externalHandlers, event);\n\n      if (event.defaultMuiPrevented) {\n        return;\n      }\n\n      if ((_listRef$current = listRef.current) != null && _listRef$current.contains(event.relatedTarget)) {\n        // focus remains within the list\n        return;\n      }\n\n      dispatch({\n        type: ListActionTypes.blur,\n        event: event\n      });\n    };\n  };\n\n  var getRootProps = function getRootProps() {\n    var externalProps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var externalEventHandlers = extractEventHandlers(externalProps);\n    return _extends({}, externalProps, {\n      'aria-activedescendant': focusManagement === 'activeDescendant' && highlightedValue != null ? getItemId(highlightedValue) : undefined,\n      tabIndex: focusManagement === 'DOM' ? -1 : 0,\n      ref: handleRef\n    }, externalEventHandlers, {\n      onBlur: createHandleBlur(externalEventHandlers),\n      onKeyDown: createHandleKeyDown(externalEventHandlers)\n    });\n  };\n\n  var getItemState = React.useCallback(function (item) {\n    var selected = (selectedValues != null ? selectedValues : []).some(function (value) {\n      return value != null && itemComparer(item, value);\n    });\n    var highlighted = highlightedValue != null && itemComparer(item, highlightedValue);\n    var focusable = focusManagement === 'DOM';\n    return {\n      focusable: focusable,\n      highlighted: highlighted,\n      selected: selected\n    };\n  }, [itemComparer, selectedValues, highlightedValue, focusManagement]);\n  var contextValue = React.useMemo(function () {\n    return {\n      dispatch: dispatch,\n      getItemState: getItemState\n    };\n  }, [dispatch, getItemState]);\n  React.useDebugValue({\n    state: state\n  });\n  return {\n    contextValue: contextValue,\n    dispatch: dispatch,\n    getRootProps: getRootProps,\n    rootRef: handleRef,\n    state: state\n  };\n}\n\nexport { useList };","map":null,"metadata":{},"sourceType":"module"}