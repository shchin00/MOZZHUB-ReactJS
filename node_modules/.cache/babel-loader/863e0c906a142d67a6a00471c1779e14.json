{"ast":null,"code":"'use client';\n\nimport * as React from 'react';\nimport { unstable_useId as useId } from '@mui/utils';\nimport { ListContext } from '../useList';\n/**\n * Stabilizes the ListContext value for the MenuItem component, so it doesn't change when sibling items update.\n *\n * @param id The id of the MenuItem. If undefined, it will be generated with useId.\n * @returns The stable ListContext value and the id of the MenuItem.\n *\n * Demos:\n *\n * - [Menu](https://mui.com/base-ui/react-menu/#hooks)\n *\n * API:\n *\n * - [useMenuItemContextStabilizer API](https://mui.com/base-ui/react-menu/hooks-api/#use-menu-item-context-stabilizer)\n */\n\nexport function useMenuItemContextStabilizer(id) {\n  var listContext = React.useContext(ListContext);\n\n  if (!listContext) {\n    throw new Error('MenuItem: ListContext was not found.');\n  }\n\n  var itemId = useId(id);\n  var getItemState = listContext.getItemState,\n      dispatch = listContext.dispatch;\n  var itemState;\n\n  if (itemId != null) {\n    itemState = getItemState(itemId);\n  } else {\n    itemState = {\n      focusable: true,\n      highlighted: false,\n      selected: false\n    };\n  }\n\n  var _itemState = itemState,\n      highlighted = _itemState.highlighted,\n      selected = _itemState.selected,\n      focusable = _itemState.focusable; // The local version of getItemState can be only called with the current Option's value.\n  // It doesn't make much sense to render an Option depending on other Options' state anyway.\n\n  var localGetItemState = React.useCallback(function (itemValue) {\n    if (itemValue !== itemId) {\n      throw new Error(['Base UI MenuItem: Tried to access the state of another MenuItem.', \"itemValue: \".concat(itemValue, \" | id: \").concat(itemId), 'This is unsupported when the MenuItem uses the MenuItemContextStabilizer as a performance optimization.'].join('/n'));\n    }\n\n    return {\n      highlighted: highlighted,\n      selected: selected,\n      focusable: focusable\n    };\n  }, [highlighted, selected, focusable, itemId]); // Create a local (per MenuItem) instance of the ListContext that changes only when\n  // the getItemState's return value changes.\n  // This makes MenuItems re-render only when their state actually change, not when any MenuItem's state changes.\n\n  var localContextValue = React.useMemo(function () {\n    return {\n      dispatch: dispatch,\n      getItemState: localGetItemState\n    };\n  }, [dispatch, localGetItemState]);\n  return {\n    contextValue: localContextValue,\n    id: itemId\n  };\n}","map":null,"metadata":{},"sourceType":"module"}