{"ast":null,"code":"import _objectSpread from \"D:\\\\MOZZHUB-ReactJS\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/objectSpread\";\nimport _slicedToArray from \"D:\\\\MOZZHUB-ReactJS\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";\nimport { computePosition, arrow as arrow$2, offset as offset$1, shift as shift$1, limitShift as limitShift$1, flip as flip$1, size as size$1, autoPlacement as autoPlacement$1, hide as hide$1, inline as inline$1 } from '@floating-ui/dom';\nexport { autoUpdate, computePosition, detectOverflow, getOverflowAncestors, platform } from '@floating-ui/dom';\nimport * as React from 'react';\nimport { useLayoutEffect, useEffect } from 'react';\nimport * as ReactDOM from 'react-dom';\nvar index = typeof document !== 'undefined' ? useLayoutEffect : useEffect; // Fork of `fast-deep-equal` that only does the comparisons we need and compares\n// functions\n\nfunction deepEqual(a, b) {\n  if (a === b) {\n    return true;\n  }\n\n  if (typeof a !== typeof b) {\n    return false;\n  }\n\n  if (typeof a === 'function' && a.toString() === b.toString()) {\n    return true;\n  }\n\n  var length;\n  var i;\n  var keys;\n\n  if (a && b && typeof a === 'object') {\n    if (Array.isArray(a)) {\n      length = a.length;\n      if (length !== b.length) return false;\n\n      for (i = length; i-- !== 0;) {\n        if (!deepEqual(a[i], b[i])) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n\n    keys = Object.keys(a);\n    length = keys.length;\n\n    if (length !== Object.keys(b).length) {\n      return false;\n    }\n\n    for (i = length; i-- !== 0;) {\n      if (!{}.hasOwnProperty.call(b, keys[i])) {\n        return false;\n      }\n    }\n\n    for (i = length; i-- !== 0;) {\n      var key = keys[i];\n\n      if (key === '_owner' && a.$$typeof) {\n        continue;\n      }\n\n      if (!deepEqual(a[key], b[key])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  return a !== a && b !== b;\n}\n\nfunction getDPR(element) {\n  if (typeof window === 'undefined') {\n    return 1;\n  }\n\n  var win = element.ownerDocument.defaultView || window;\n  return win.devicePixelRatio || 1;\n}\n\nfunction roundByDPR(element, value) {\n  var dpr = getDPR(element);\n  return Math.round(value * dpr) / dpr;\n}\n\nfunction useLatestRef(value) {\n  var ref = React.useRef(value);\n  index(function () {\n    ref.current = value;\n  });\n  return ref;\n}\n/**\n * Provides data to position a floating element.\n * @see https://floating-ui.com/docs/useFloating\n */\n\n\nfunction useFloating(options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var _options = options,\n      _options$placement = _options.placement,\n      placement = _options$placement === void 0 ? 'bottom' : _options$placement,\n      _options$strategy = _options.strategy,\n      strategy = _options$strategy === void 0 ? 'absolute' : _options$strategy,\n      _options$middleware = _options.middleware,\n      middleware = _options$middleware === void 0 ? [] : _options$middleware,\n      platform = _options.platform,\n      _options$elements = _options.elements;\n  _options$elements = _options$elements === void 0 ? {} : _options$elements;\n  var externalReference = _options$elements.reference,\n      externalFloating = _options$elements.floating,\n      _options$transform = _options.transform,\n      transform = _options$transform === void 0 ? true : _options$transform,\n      whileElementsMounted = _options.whileElementsMounted,\n      open = _options.open;\n\n  var _React$useState = React.useState({\n    x: 0,\n    y: 0,\n    strategy: strategy,\n    placement: placement,\n    middlewareData: {},\n    isPositioned: false\n  }),\n      _React$useState2 = _slicedToArray(_React$useState, 2),\n      data = _React$useState2[0],\n      setData = _React$useState2[1];\n\n  var _React$useState3 = React.useState(middleware),\n      _React$useState4 = _slicedToArray(_React$useState3, 2),\n      latestMiddleware = _React$useState4[0],\n      setLatestMiddleware = _React$useState4[1];\n\n  if (!deepEqual(latestMiddleware, middleware)) {\n    setLatestMiddleware(middleware);\n  }\n\n  var _React$useState5 = React.useState(null),\n      _React$useState6 = _slicedToArray(_React$useState5, 2),\n      _reference = _React$useState6[0],\n      _setReference = _React$useState6[1];\n\n  var _React$useState7 = React.useState(null),\n      _React$useState8 = _slicedToArray(_React$useState7, 2),\n      _floating = _React$useState8[0],\n      _setFloating = _React$useState8[1];\n\n  var setReference = React.useCallback(function (node) {\n    if (node !== referenceRef.current) {\n      referenceRef.current = node;\n\n      _setReference(node);\n    }\n  }, []);\n  var setFloating = React.useCallback(function (node) {\n    if (node !== floatingRef.current) {\n      floatingRef.current = node;\n\n      _setFloating(node);\n    }\n  }, []);\n  var referenceEl = externalReference || _reference;\n  var floatingEl = externalFloating || _floating;\n  var referenceRef = React.useRef(null);\n  var floatingRef = React.useRef(null);\n  var dataRef = React.useRef(data);\n  var hasWhileElementsMounted = whileElementsMounted != null;\n  var whileElementsMountedRef = useLatestRef(whileElementsMounted);\n  var platformRef = useLatestRef(platform);\n  var update = React.useCallback(function () {\n    if (!referenceRef.current || !floatingRef.current) {\n      return;\n    }\n\n    var config = {\n      placement: placement,\n      strategy: strategy,\n      middleware: latestMiddleware\n    };\n\n    if (platformRef.current) {\n      config.platform = platformRef.current;\n    }\n\n    computePosition(referenceRef.current, floatingRef.current, config).then(function (data) {\n      var fullData = _objectSpread({}, data, {\n        isPositioned: true\n      });\n\n      if (isMountedRef.current && !deepEqual(dataRef.current, fullData)) {\n        dataRef.current = fullData;\n        ReactDOM.flushSync(function () {\n          setData(fullData);\n        });\n      }\n    });\n  }, [latestMiddleware, placement, strategy, platformRef]);\n  index(function () {\n    if (open === false && dataRef.current.isPositioned) {\n      dataRef.current.isPositioned = false;\n      setData(function (data) {\n        return _objectSpread({}, data, {\n          isPositioned: false\n        });\n      });\n    }\n  }, [open]);\n  var isMountedRef = React.useRef(false);\n  index(function () {\n    isMountedRef.current = true;\n    return function () {\n      isMountedRef.current = false;\n    };\n  }, []);\n  index(function () {\n    if (referenceEl) referenceRef.current = referenceEl;\n    if (floatingEl) floatingRef.current = floatingEl;\n\n    if (referenceEl && floatingEl) {\n      if (whileElementsMountedRef.current) {\n        return whileElementsMountedRef.current(referenceEl, floatingEl, update);\n      }\n\n      update();\n    }\n  }, [referenceEl, floatingEl, update, whileElementsMountedRef, hasWhileElementsMounted]);\n  var refs = React.useMemo(function () {\n    return {\n      reference: referenceRef,\n      floating: floatingRef,\n      setReference: setReference,\n      setFloating: setFloating\n    };\n  }, [setReference, setFloating]);\n  var elements = React.useMemo(function () {\n    return {\n      reference: referenceEl,\n      floating: floatingEl\n    };\n  }, [referenceEl, floatingEl]);\n  var floatingStyles = React.useMemo(function () {\n    var initialStyles = {\n      position: strategy,\n      left: 0,\n      top: 0\n    };\n\n    if (!elements.floating) {\n      return initialStyles;\n    }\n\n    var x = roundByDPR(elements.floating, data.x);\n    var y = roundByDPR(elements.floating, data.y);\n\n    if (transform) {\n      return _objectSpread({}, initialStyles, {\n        transform: \"translate(\" + x + \"px, \" + y + \"px)\"\n      }, getDPR(elements.floating) >= 1.5 && {\n        willChange: 'transform'\n      });\n    }\n\n    return {\n      position: strategy,\n      left: x,\n      top: y\n    };\n  }, [strategy, transform, elements.floating, data.x, data.y]);\n  return React.useMemo(function () {\n    return _objectSpread({}, data, {\n      update: update,\n      refs: refs,\n      elements: elements,\n      floatingStyles: floatingStyles\n    });\n  }, [data, update, refs, elements, floatingStyles]);\n}\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * This wraps the core `arrow` middleware to allow React refs as the element.\n * @see https://floating-ui.com/docs/arrow\n */\n\n\nvar arrow$1 = function arrow$1(options) {\n  function isRef(value) {\n    return {}.hasOwnProperty.call(value, 'current');\n  }\n\n  return {\n    name: 'arrow',\n    options: options,\n    fn: function fn(state) {\n      var _ref = typeof options === 'function' ? options(state) : options,\n          element = _ref.element,\n          padding = _ref.padding;\n\n      if (element && isRef(element)) {\n        if (element.current != null) {\n          return arrow$2({\n            element: element.current,\n            padding: padding\n          }).fn(state);\n        }\n\n        return {};\n      }\n\n      if (element) {\n        return arrow$2({\n          element: element,\n          padding: padding\n        }).fn(state);\n      }\n\n      return {};\n    }\n  };\n};\n/**\n * Modifies the placement by translating the floating element along the\n * specified axes.\n * A number (shorthand for `mainAxis` or distance), or an axes configuration\n * object may be passed.\n * @see https://floating-ui.com/docs/offset\n */\n\n\nvar offset = function offset(options, deps) {\n  return _objectSpread({}, offset$1(options), {\n    options: [options, deps]\n  });\n};\n/**\n * Optimizes the visibility of the floating element by shifting it in order to\n * keep it in view when it will overflow the clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */\n\n\nvar shift = function shift(options, deps) {\n  return _objectSpread({}, shift$1(options), {\n    options: [options, deps]\n  });\n};\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */\n\n\nvar limitShift = function limitShift(options, deps) {\n  return _objectSpread({}, limitShift$1(options), {\n    options: [options, deps]\n  });\n};\n/**\n * Optimizes the visibility of the floating element by flipping the `placement`\n * in order to keep it in view when the preferred placement(s) will overflow the\n * clipping boundary. Alternative to `autoPlacement`.\n * @see https://floating-ui.com/docs/flip\n */\n\n\nvar flip = function flip(options, deps) {\n  return _objectSpread({}, flip$1(options), {\n    options: [options, deps]\n  });\n};\n/**\n * Provides data that allows you to change the size of the floating element —\n * for instance, prevent it from overflowing the clipping boundary or match the\n * width of the reference element.\n * @see https://floating-ui.com/docs/size\n */\n\n\nvar size = function size(options, deps) {\n  return _objectSpread({}, size$1(options), {\n    options: [options, deps]\n  });\n};\n/**\n * Optimizes the visibility of the floating element by choosing the placement\n * that has the most space available automatically, without needing to specify a\n * preferred placement. Alternative to `flip`.\n * @see https://floating-ui.com/docs/autoPlacement\n */\n\n\nvar autoPlacement = function autoPlacement(options, deps) {\n  return _objectSpread({}, autoPlacement$1(options), {\n    options: [options, deps]\n  });\n};\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */\n\n\nvar hide = function hide(options, deps) {\n  return _objectSpread({}, hide$1(options), {\n    options: [options, deps]\n  });\n};\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */\n\n\nvar inline = function inline(options, deps) {\n  return _objectSpread({}, inline$1(options), {\n    options: [options, deps]\n  });\n};\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * This wraps the core `arrow` middleware to allow React refs as the element.\n * @see https://floating-ui.com/docs/arrow\n */\n\n\nvar arrow = function arrow(options, deps) {\n  return _objectSpread({}, arrow$1(options), {\n    options: [options, deps]\n  });\n};\n\nexport { arrow, autoPlacement, flip, hide, inline, limitShift, offset, shift, size, useFloating };","map":null,"metadata":{},"sourceType":"module"}