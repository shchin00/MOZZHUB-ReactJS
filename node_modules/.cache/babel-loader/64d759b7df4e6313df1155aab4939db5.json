{"ast":null,"code":"'use client';\n\nimport _slicedToArray from \"D:\\\\MOZZHUB-ReactJS\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport { unstable_ownerDocument as ownerDocument, unstable_useForkRef as useForkRef, unstable_useEventCallback as useEventCallback, unstable_createChainedFunction as createChainedFunction } from '@mui/utils';\nimport { extractEventHandlers } from '../utils';\nimport { ModalManager, ariaHidden } from './ModalManager';\n\nfunction getContainer(container) {\n  return typeof container === 'function' ? container() : container;\n}\n\nfunction getHasTransition(children) {\n  return children ? children.props.hasOwnProperty('in') : false;\n} // A modal manager used to track and manage the state of open Modals.\n// Modals don't open on the server so this won't conflict with concurrent requests.\n\n\nvar defaultManager = new ModalManager();\n/**\n *\n * Demos:\n *\n * - [Modal](https://mui.com/base-ui/react-modal/#hook)\n *\n * API:\n *\n * - [useModal API](https://mui.com/base-ui/react-modal/hooks-api/#use-modal)\n */\n\nexport function useModal(parameters) {\n  var container = parameters.container,\n      _parameters$disableEs = parameters.disableEscapeKeyDown,\n      disableEscapeKeyDown = _parameters$disableEs === void 0 ? false : _parameters$disableEs,\n      _parameters$disableSc = parameters.disableScrollLock,\n      disableScrollLock = _parameters$disableSc === void 0 ? false : _parameters$disableSc,\n      _parameters$manager = parameters.manager,\n      manager = _parameters$manager === void 0 ? defaultManager : _parameters$manager,\n      _parameters$closeAfte = parameters.closeAfterTransition,\n      closeAfterTransition = _parameters$closeAfte === void 0 ? false : _parameters$closeAfte,\n      onTransitionEnter = parameters.onTransitionEnter,\n      onTransitionExited = parameters.onTransitionExited,\n      children = parameters.children,\n      onClose = parameters.onClose,\n      open = parameters.open,\n      rootRef = parameters.rootRef; // @ts-ignore internal logic\n\n  var modal = React.useRef({});\n  var mountNodeRef = React.useRef(null);\n  var modalRef = React.useRef(null);\n  var handleRef = useForkRef(modalRef, rootRef);\n\n  var _React$useState = React.useState(!open),\n      _React$useState2 = _slicedToArray(_React$useState, 2),\n      exited = _React$useState2[0],\n      setExited = _React$useState2[1];\n\n  var hasTransition = getHasTransition(children);\n  var ariaHiddenProp = true;\n\n  if (parameters['aria-hidden'] === 'false' || parameters['aria-hidden'] === false) {\n    ariaHiddenProp = false;\n  }\n\n  var getDoc = function getDoc() {\n    return ownerDocument(mountNodeRef.current);\n  };\n\n  var getModal = function getModal() {\n    modal.current.modalRef = modalRef.current;\n    modal.current.mount = mountNodeRef.current;\n    return modal.current;\n  };\n\n  var handleMounted = function handleMounted() {\n    manager.mount(getModal(), {\n      disableScrollLock: disableScrollLock\n    }); // Fix a bug on Chrome where the scroll isn't initially 0.\n\n    if (modalRef.current) {\n      modalRef.current.scrollTop = 0;\n    }\n  };\n\n  var handleOpen = useEventCallback(function () {\n    var resolvedContainer = getContainer(container) || getDoc().body;\n    manager.add(getModal(), resolvedContainer); // The element was already mounted.\n\n    if (modalRef.current) {\n      handleMounted();\n    }\n  });\n  var isTopModal = React.useCallback(function () {\n    return manager.isTopModal(getModal());\n  }, [manager]);\n  var handlePortalRef = useEventCallback(function (node) {\n    mountNodeRef.current = node;\n\n    if (!node) {\n      return;\n    }\n\n    if (open && isTopModal()) {\n      handleMounted();\n    } else if (modalRef.current) {\n      ariaHidden(modalRef.current, ariaHiddenProp);\n    }\n  });\n  var handleClose = React.useCallback(function () {\n    manager.remove(getModal(), ariaHiddenProp);\n  }, [ariaHiddenProp, manager]);\n  React.useEffect(function () {\n    return function () {\n      handleClose();\n    };\n  }, [handleClose]);\n  React.useEffect(function () {\n    if (open) {\n      handleOpen();\n    } else if (!hasTransition || !closeAfterTransition) {\n      handleClose();\n    }\n  }, [open, handleClose, hasTransition, closeAfterTransition, handleOpen]);\n\n  var createHandleKeyDown = function createHandleKeyDown(otherHandlers) {\n    return function (event) {\n      var _otherHandlers$onKeyD;\n\n      (_otherHandlers$onKeyD = otherHandlers.onKeyDown) == null || _otherHandlers$onKeyD.call(otherHandlers, event); // The handler doesn't take event.defaultPrevented into account:\n      //\n      // event.preventDefault() is meant to stop default behaviors like\n      // clicking a checkbox to check it, hitting a button to submit a form,\n      // and hitting left arrow to move the cursor in a text input etc.\n      // Only special HTML elements have these default behaviors.\n\n      if (event.key !== 'Escape' || event.which === 229 || // Wait until IME is settled.\n      !isTopModal()) {\n        return;\n      }\n\n      if (!disableEscapeKeyDown) {\n        // Swallow the event, in case someone is listening for the escape key on the body.\n        event.stopPropagation();\n\n        if (onClose) {\n          onClose(event, 'escapeKeyDown');\n        }\n      }\n    };\n  };\n\n  var createHandleBackdropClick = function createHandleBackdropClick(otherHandlers) {\n    return function (event) {\n      var _otherHandlers$onClic;\n\n      (_otherHandlers$onClic = otherHandlers.onClick) == null || _otherHandlers$onClic.call(otherHandlers, event);\n\n      if (event.target !== event.currentTarget) {\n        return;\n      }\n\n      if (onClose) {\n        onClose(event, 'backdropClick');\n      }\n    };\n  };\n\n  var getRootProps = function getRootProps() {\n    var otherHandlers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var propsEventHandlers = extractEventHandlers(parameters); // The custom event handlers shouldn't be spread on the root element\n\n    delete propsEventHandlers.onTransitionEnter;\n    delete propsEventHandlers.onTransitionExited;\n\n    var externalEventHandlers = _extends({}, propsEventHandlers, otherHandlers);\n\n    return _extends({\n      role: 'presentation'\n    }, externalEventHandlers, {\n      onKeyDown: createHandleKeyDown(externalEventHandlers),\n      ref: handleRef\n    });\n  };\n\n  var getBackdropProps = function getBackdropProps() {\n    var otherHandlers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var externalEventHandlers = otherHandlers;\n    return _extends({\n      'aria-hidden': true\n    }, externalEventHandlers, {\n      onClick: createHandleBackdropClick(externalEventHandlers),\n      open: open\n    });\n  };\n\n  var getTransitionProps = function getTransitionProps() {\n    var handleEnter = function handleEnter() {\n      setExited(false);\n\n      if (onTransitionEnter) {\n        onTransitionEnter();\n      }\n    };\n\n    var handleExited = function handleExited() {\n      setExited(true);\n\n      if (onTransitionExited) {\n        onTransitionExited();\n      }\n\n      if (closeAfterTransition) {\n        handleClose();\n      }\n    };\n\n    return {\n      onEnter: createChainedFunction(handleEnter, children == null ? void 0 : children.props.onEnter),\n      onExited: createChainedFunction(handleExited, children == null ? void 0 : children.props.onExited)\n    };\n  };\n\n  return {\n    getRootProps: getRootProps,\n    getBackdropProps: getBackdropProps,\n    getTransitionProps: getTransitionProps,\n    rootRef: handleRef,\n    portalRef: handlePortalRef,\n    isTopModal: isTopModal,\n    exited: exited,\n    hasTransition: hasTransition\n  };\n}","map":null,"metadata":{},"sourceType":"module"}