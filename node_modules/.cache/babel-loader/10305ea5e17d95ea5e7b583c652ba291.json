{"ast":null,"code":"import _slicedToArray from \"D:\\\\MOZZHUB-ReactJS\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";\nimport _regeneratorRuntime from \"D:\\\\MOZZHUB-ReactJS\\\\node_modules\\\\@babel\\\\runtime/regenerator\";\nimport _asyncToGenerator from \"D:\\\\MOZZHUB-ReactJS\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/asyncToGenerator\";\nimport _toConsumableArray from \"D:\\\\MOZZHUB-ReactJS\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/toConsumableArray\";\nimport _objectSpread from \"D:\\\\MOZZHUB-ReactJS\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/objectSpread\";\nimport { rectToClientRect, detectOverflow as detectOverflow$1, offset as offset$1, autoPlacement as autoPlacement$1, shift as shift$1, flip as flip$1, size as size$1, hide as hide$1, arrow as arrow$1, inline as inline$1, limitShift as limitShift$1, computePosition as computePosition$1 } from '@floating-ui/core';\nimport { round, createCoords, max, min, floor } from '@floating-ui/utils';\nimport { getComputedStyle, isHTMLElement, isElement, getWindow, isWebKit, getDocumentElement, getNodeName, isOverflowElement, getNodeScroll, getOverflowAncestors, getParentNode, isLastTraversableNode, isContainingBlock, isTableElement, getContainingBlock } from '@floating-ui/utils/dom';\nexport { getOverflowAncestors } from '@floating-ui/utils/dom';\n\nfunction getCssDimensions(element) {\n  var css = getComputedStyle(element); // In testing environments, the `width` and `height` properties are empty\n  // strings for SVG elements, returning NaN. Fallback to `0` in this case.\n\n  var width = parseFloat(css.width) || 0;\n  var height = parseFloat(css.height) || 0;\n  var hasOffset = isHTMLElement(element);\n  var offsetWidth = hasOffset ? element.offsetWidth : width;\n  var offsetHeight = hasOffset ? element.offsetHeight : height;\n  var shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;\n\n  if (shouldFallback) {\n    width = offsetWidth;\n    height = offsetHeight;\n  }\n\n  return {\n    width: width,\n    height: height,\n    $: shouldFallback\n  };\n}\n\nfunction unwrapElement(element) {\n  return !isElement(element) ? element.contextElement : element;\n}\n\nfunction getScale(element) {\n  var domElement = unwrapElement(element);\n\n  if (!isHTMLElement(domElement)) {\n    return createCoords(1);\n  }\n\n  var rect = domElement.getBoundingClientRect();\n\n  var _getCssDimensions = getCssDimensions(domElement),\n      width = _getCssDimensions.width,\n      height = _getCssDimensions.height,\n      $ = _getCssDimensions.$;\n\n  var x = ($ ? round(rect.width) : rect.width) / width;\n  var y = ($ ? round(rect.height) : rect.height) / height; // 0, NaN, or Infinity should always fallback to 1.\n\n  if (!x || !Number.isFinite(x)) {\n    x = 1;\n  }\n\n  if (!y || !Number.isFinite(y)) {\n    y = 1;\n  }\n\n  return {\n    x: x,\n    y: y\n  };\n}\n\nvar noOffsets =\n/*#__PURE__*/\ncreateCoords(0);\n\nfunction getVisualOffsets(element) {\n  var win = getWindow(element);\n\n  if (!isWebKit() || !win.visualViewport) {\n    return noOffsets;\n  }\n\n  return {\n    x: win.visualViewport.offsetLeft,\n    y: win.visualViewport.offsetTop\n  };\n}\n\nfunction shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {\n  if (isFixed === void 0) {\n    isFixed = false;\n  }\n\n  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {\n    return false;\n  }\n\n  return isFixed;\n}\n\nfunction getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {\n  if (includeScale === void 0) {\n    includeScale = false;\n  }\n\n  if (isFixedStrategy === void 0) {\n    isFixedStrategy = false;\n  }\n\n  var clientRect = element.getBoundingClientRect();\n  var domElement = unwrapElement(element);\n  var scale = createCoords(1);\n\n  if (includeScale) {\n    if (offsetParent) {\n      if (isElement(offsetParent)) {\n        scale = getScale(offsetParent);\n      }\n    } else {\n      scale = getScale(element);\n    }\n  }\n\n  var visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);\n  var x = (clientRect.left + visualOffsets.x) / scale.x;\n  var y = (clientRect.top + visualOffsets.y) / scale.y;\n  var width = clientRect.width / scale.x;\n  var height = clientRect.height / scale.y;\n\n  if (domElement) {\n    var win = getWindow(domElement);\n    var offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;\n    var currentWin = win;\n    var currentIFrame = currentWin.frameElement;\n\n    while (currentIFrame && offsetParent && offsetWin !== currentWin) {\n      var iframeScale = getScale(currentIFrame);\n      var iframeRect = currentIFrame.getBoundingClientRect();\n      var css = getComputedStyle(currentIFrame);\n      var left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;\n      var top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;\n      x *= iframeScale.x;\n      y *= iframeScale.y;\n      width *= iframeScale.x;\n      height *= iframeScale.y;\n      x += left;\n      y += top;\n      currentWin = getWindow(currentIFrame);\n      currentIFrame = currentWin.frameElement;\n    }\n  }\n\n  return rectToClientRect({\n    width: width,\n    height: height,\n    x: x,\n    y: y\n  });\n}\n\nvar topLayerSelectors = [':popover-open', ':modal'];\n\nfunction isTopLayer(element) {\n  return topLayerSelectors.some(function (selector) {\n    try {\n      return element.matches(selector);\n    } catch (e) {\n      return false;\n    }\n  });\n}\n\nfunction convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {\n  var elements = _ref.elements,\n      rect = _ref.rect,\n      offsetParent = _ref.offsetParent,\n      strategy = _ref.strategy;\n  var isFixed = strategy === 'fixed';\n  var documentElement = getDocumentElement(offsetParent);\n  var topLayer = elements ? isTopLayer(elements.floating) : false;\n\n  if (offsetParent === documentElement || topLayer && isFixed) {\n    return rect;\n  }\n\n  var scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  var scale = createCoords(1);\n  var offsets = createCoords(0);\n  var isOffsetParentAnElement = isHTMLElement(offsetParent);\n\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n\n    if (isHTMLElement(offsetParent)) {\n      var offsetRect = getBoundingClientRect(offsetParent);\n      scale = getScale(offsetParent);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    }\n  }\n\n  return {\n    width: rect.width * scale.x,\n    height: rect.height * scale.y,\n    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x,\n    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y\n  };\n}\n\nfunction getClientRects(element) {\n  return Array.from(element.getClientRects());\n}\n\nfunction getWindowScrollBarX(element) {\n  // If <html> has a CSS width greater than the viewport, then this will be\n  // incorrect for RTL.\n  return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;\n} // Gets the entire size of the scrollable document area, even extending outside\n// of the `<html>` and `<body>` rect bounds if horizontally scrollable.\n\n\nfunction getDocumentRect(element) {\n  var html = getDocumentElement(element);\n  var scroll = getNodeScroll(element);\n  var body = element.ownerDocument.body;\n  var width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);\n  var height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);\n  var x = -scroll.scrollLeft + getWindowScrollBarX(element);\n  var y = -scroll.scrollTop;\n\n  if (getComputedStyle(body).direction === 'rtl') {\n    x += max(html.clientWidth, body.clientWidth) - width;\n  }\n\n  return {\n    width: width,\n    height: height,\n    x: x,\n    y: y\n  };\n}\n\nfunction getViewportRect(element, strategy) {\n  var win = getWindow(element);\n  var html = getDocumentElement(element);\n  var visualViewport = win.visualViewport;\n  var width = html.clientWidth;\n  var height = html.clientHeight;\n  var x = 0;\n  var y = 0;\n\n  if (visualViewport) {\n    width = visualViewport.width;\n    height = visualViewport.height;\n    var visualViewportBased = isWebKit();\n\n    if (!visualViewportBased || visualViewportBased && strategy === 'fixed') {\n      x = visualViewport.offsetLeft;\n      y = visualViewport.offsetTop;\n    }\n  }\n\n  return {\n    width: width,\n    height: height,\n    x: x,\n    y: y\n  };\n} // Returns the inner client rect, subtracting scrollbars if present.\n\n\nfunction getInnerBoundingClientRect(element, strategy) {\n  var clientRect = getBoundingClientRect(element, true, strategy === 'fixed');\n  var top = clientRect.top + element.clientTop;\n  var left = clientRect.left + element.clientLeft;\n  var scale = isHTMLElement(element) ? getScale(element) : createCoords(1);\n  var width = element.clientWidth * scale.x;\n  var height = element.clientHeight * scale.y;\n  var x = left * scale.x;\n  var y = top * scale.y;\n  return {\n    width: width,\n    height: height,\n    x: x,\n    y: y\n  };\n}\n\nfunction getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {\n  var rect;\n\n  if (clippingAncestor === 'viewport') {\n    rect = getViewportRect(element, strategy);\n  } else if (clippingAncestor === 'document') {\n    rect = getDocumentRect(getDocumentElement(element));\n  } else if (isElement(clippingAncestor)) {\n    rect = getInnerBoundingClientRect(clippingAncestor, strategy);\n  } else {\n    var visualOffsets = getVisualOffsets(element);\n    rect = _objectSpread({}, clippingAncestor, {\n      x: clippingAncestor.x - visualOffsets.x,\n      y: clippingAncestor.y - visualOffsets.y\n    });\n  }\n\n  return rectToClientRect(rect);\n}\n\nfunction hasFixedPositionAncestor(element, stopNode) {\n  var parentNode = getParentNode(element);\n\n  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {\n    return false;\n  }\n\n  return getComputedStyle(parentNode).position === 'fixed' || hasFixedPositionAncestor(parentNode, stopNode);\n} // A \"clipping ancestor\" is an `overflow` element with the characteristic of\n// clipping (or hiding) child elements. This returns all clipping ancestors\n// of the given element up the tree.\n\n\nfunction getClippingElementAncestors(element, cache) {\n  var cachedResult = cache.get(element);\n\n  if (cachedResult) {\n    return cachedResult;\n  }\n\n  var result = getOverflowAncestors(element, [], false).filter(function (el) {\n    return isElement(el) && getNodeName(el) !== 'body';\n  });\n  var currentContainingBlockComputedStyle = null;\n  var elementIsFixed = getComputedStyle(element).position === 'fixed';\n  var currentNode = elementIsFixed ? getParentNode(element) : element; // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n\n  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    var computedStyle = getComputedStyle(currentNode);\n    var currentNodeIsContaining = isContainingBlock(currentNode);\n\n    if (!currentNodeIsContaining && computedStyle.position === 'fixed') {\n      currentContainingBlockComputedStyle = null;\n    }\n\n    var shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === 'static' && !!currentContainingBlockComputedStyle && ['absolute', 'fixed'].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);\n\n    if (shouldDropCurrentNode) {\n      // Drop non-containing blocks.\n      result = result.filter(function (ancestor) {\n        return ancestor !== currentNode;\n      });\n    } else {\n      // Record last containing block for next iteration.\n      currentContainingBlockComputedStyle = computedStyle;\n    }\n\n    currentNode = getParentNode(currentNode);\n  }\n\n  cache.set(element, result);\n  return result;\n} // Gets the maximum area that the element is visible in due to any number of\n// clipping ancestors.\n\n\nfunction getClippingRect(_ref) {\n  var element = _ref.element,\n      boundary = _ref.boundary,\n      rootBoundary = _ref.rootBoundary,\n      strategy = _ref.strategy;\n  var elementClippingAncestors = boundary === 'clippingAncestors' ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);\n\n  var clippingAncestors = _toConsumableArray(elementClippingAncestors).concat([rootBoundary]);\n\n  var firstClippingAncestor = clippingAncestors[0];\n  var clippingRect = clippingAncestors.reduce(function (accRect, clippingAncestor) {\n    var rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);\n    accRect.top = max(rect.top, accRect.top);\n    accRect.right = min(rect.right, accRect.right);\n    accRect.bottom = min(rect.bottom, accRect.bottom);\n    accRect.left = max(rect.left, accRect.left);\n    return accRect;\n  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));\n  return {\n    width: clippingRect.right - clippingRect.left,\n    height: clippingRect.bottom - clippingRect.top,\n    x: clippingRect.left,\n    y: clippingRect.top\n  };\n}\n\nfunction getDimensions(element) {\n  var _getCssDimensions2 = getCssDimensions(element),\n      width = _getCssDimensions2.width,\n      height = _getCssDimensions2.height;\n\n  return {\n    width: width,\n    height: height\n  };\n}\n\nfunction getRectRelativeToOffsetParent(element, offsetParent, strategy) {\n  var isOffsetParentAnElement = isHTMLElement(offsetParent);\n  var documentElement = getDocumentElement(offsetParent);\n  var isFixed = strategy === 'fixed';\n  var rect = getBoundingClientRect(element, true, isFixed, offsetParent);\n  var scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  var offsets = createCoords(0);\n\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n\n    if (isOffsetParentAnElement) {\n      var offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    } else if (documentElement) {\n      offsets.x = getWindowScrollBarX(documentElement);\n    }\n  }\n\n  var x = rect.left + scroll.scrollLeft - offsets.x;\n  var y = rect.top + scroll.scrollTop - offsets.y;\n  return {\n    x: x,\n    y: y,\n    width: rect.width,\n    height: rect.height\n  };\n}\n\nfunction isStaticPositioned(element) {\n  return getComputedStyle(element).position === 'static';\n}\n\nfunction getTrueOffsetParent(element, polyfill) {\n  if (!isHTMLElement(element) || getComputedStyle(element).position === 'fixed') {\n    return null;\n  }\n\n  if (polyfill) {\n    return polyfill(element);\n  }\n\n  return element.offsetParent;\n} // Gets the closest ancestor positioned element. Handles some edge cases,\n// such as table ancestors and cross browser bugs.\n\n\nfunction getOffsetParent(element, polyfill) {\n  var win = getWindow(element);\n\n  if (isTopLayer(element)) {\n    return win;\n  }\n\n  if (!isHTMLElement(element)) {\n    var svgOffsetParent = getParentNode(element);\n\n    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {\n      if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {\n        return svgOffsetParent;\n      }\n\n      svgOffsetParent = getParentNode(svgOffsetParent);\n    }\n\n    return win;\n  }\n\n  var offsetParent = getTrueOffsetParent(element, polyfill);\n\n  while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {\n    offsetParent = getTrueOffsetParent(offsetParent, polyfill);\n  }\n\n  if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {\n    return win;\n  }\n\n  return offsetParent || getContainingBlock(element) || win;\n}\n\nvar getElementRects =\n/*#__PURE__*/\nfunction () {\n  var _ref2 = _asyncToGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee(data) {\n    var getOffsetParentFn, getDimensionsFn, floatingDimensions;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            getOffsetParentFn = this.getOffsetParent || getOffsetParent;\n            getDimensionsFn = this.getDimensions;\n            _context.next = 4;\n            return getDimensionsFn(data.floating);\n\n          case 4:\n            floatingDimensions = _context.sent;\n            _context.t0 = getRectRelativeToOffsetParent;\n            _context.t1 = data.reference;\n            _context.next = 9;\n            return getOffsetParentFn(data.floating);\n\n          case 9:\n            _context.t2 = _context.sent;\n            _context.t3 = data.strategy;\n            _context.t4 = (0, _context.t0)(_context.t1, _context.t2, _context.t3);\n            _context.t5 = {\n              x: 0,\n              y: 0,\n              width: floatingDimensions.width,\n              height: floatingDimensions.height\n            };\n            return _context.abrupt(\"return\", {\n              reference: _context.t4,\n              floating: _context.t5\n            });\n\n          case 14:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, this);\n  }));\n\n  return function getElementRects(_x) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n\nfunction isRTL(element) {\n  return getComputedStyle(element).direction === 'rtl';\n}\n\nvar platform = {\n  convertOffsetParentRelativeRectToViewportRelativeRect: convertOffsetParentRelativeRectToViewportRelativeRect,\n  getDocumentElement: getDocumentElement,\n  getClippingRect: getClippingRect,\n  getOffsetParent: getOffsetParent,\n  getElementRects: getElementRects,\n  getClientRects: getClientRects,\n  getDimensions: getDimensions,\n  getScale: getScale,\n  isElement: isElement,\n  isRTL: isRTL\n}; // https://samthor.au/2021/observing-dom/\n\nfunction observeMove(element, onMove) {\n  var io = null;\n  var timeoutId;\n  var root = getDocumentElement(element);\n\n  function cleanup() {\n    var _io;\n\n    clearTimeout(timeoutId);\n    (_io = io) == null || _io.disconnect();\n    io = null;\n  }\n\n  function refresh(skip, threshold) {\n    if (skip === void 0) {\n      skip = false;\n    }\n\n    if (threshold === void 0) {\n      threshold = 1;\n    }\n\n    cleanup();\n\n    var _element$getBoundingC = element.getBoundingClientRect(),\n        left = _element$getBoundingC.left,\n        top = _element$getBoundingC.top,\n        width = _element$getBoundingC.width,\n        height = _element$getBoundingC.height;\n\n    if (!skip) {\n      onMove();\n    }\n\n    if (!width || !height) {\n      return;\n    }\n\n    var insetTop = floor(top);\n    var insetRight = floor(root.clientWidth - (left + width));\n    var insetBottom = floor(root.clientHeight - (top + height));\n    var insetLeft = floor(left);\n    var rootMargin = -insetTop + \"px \" + -insetRight + \"px \" + -insetBottom + \"px \" + -insetLeft + \"px\";\n    var options = {\n      rootMargin: rootMargin,\n      threshold: max(0, min(1, threshold)) || 1\n    };\n    var isFirstUpdate = true;\n\n    function handleObserve(entries) {\n      var ratio = entries[0].intersectionRatio;\n\n      if (ratio !== threshold) {\n        if (!isFirstUpdate) {\n          return refresh();\n        }\n\n        if (!ratio) {\n          // If the reference is clipped, the ratio is 0. Throttle the refresh\n          // to prevent an infinite loop of updates.\n          timeoutId = setTimeout(function () {\n            refresh(false, 1e-7);\n          }, 1000);\n        } else {\n          refresh(false, ratio);\n        }\n      }\n\n      isFirstUpdate = false;\n    } // Older browsers don't support a `document` as the root and will throw an\n    // error.\n\n\n    try {\n      io = new IntersectionObserver(handleObserve, _objectSpread({}, options, {\n        // Handle <iframe>s\n        root: root.ownerDocument\n      }));\n    } catch (e) {\n      io = new IntersectionObserver(handleObserve, options);\n    }\n\n    io.observe(element);\n  }\n\n  refresh(true);\n  return cleanup;\n}\n/**\n * Automatically updates the position of the floating element when necessary.\n * Should only be called when the floating element is mounted on the DOM or\n * visible on the screen.\n * @returns cleanup function that should be invoked when the floating element is\n * removed from the DOM or hidden from the screen.\n * @see https://floating-ui.com/docs/autoUpdate\n */\n\n\nfunction autoUpdate(reference, floating, update, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var _options = options,\n      _options$ancestorScro = _options.ancestorScroll,\n      ancestorScroll = _options$ancestorScro === void 0 ? true : _options$ancestorScro,\n      _options$ancestorResi = _options.ancestorResize,\n      ancestorResize = _options$ancestorResi === void 0 ? true : _options$ancestorResi,\n      _options$elementResiz = _options.elementResize,\n      elementResize = _options$elementResiz === void 0 ? typeof ResizeObserver === 'function' : _options$elementResiz,\n      _options$layoutShift = _options.layoutShift,\n      layoutShift = _options$layoutShift === void 0 ? typeof IntersectionObserver === 'function' : _options$layoutShift,\n      _options$animationFra = _options.animationFrame,\n      animationFrame = _options$animationFra === void 0 ? false : _options$animationFra;\n  var referenceEl = unwrapElement(reference);\n  var ancestors = ancestorScroll || ancestorResize ? _toConsumableArray(referenceEl ? getOverflowAncestors(referenceEl) : []).concat(_toConsumableArray(getOverflowAncestors(floating))) : [];\n  ancestors.forEach(function (ancestor) {\n    ancestorScroll && ancestor.addEventListener('scroll', update, {\n      passive: true\n    });\n    ancestorResize && ancestor.addEventListener('resize', update);\n  });\n  var cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;\n  var reobserveFrame = -1;\n  var resizeObserver = null;\n\n  if (elementResize) {\n    resizeObserver = new ResizeObserver(function (_ref) {\n      var _ref3 = _slicedToArray(_ref, 1),\n          firstEntry = _ref3[0];\n\n      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {\n        // Prevent update loops when using the `size` middleware.\n        // https://github.com/floating-ui/floating-ui/issues/1740\n        resizeObserver.unobserve(floating);\n        cancelAnimationFrame(reobserveFrame);\n        reobserveFrame = requestAnimationFrame(function () {\n          var _resizeObserver;\n\n          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);\n        });\n      }\n\n      update();\n    });\n\n    if (referenceEl && !animationFrame) {\n      resizeObserver.observe(referenceEl);\n    }\n\n    resizeObserver.observe(floating);\n  }\n\n  var frameId;\n  var prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;\n\n  if (animationFrame) {\n    frameLoop();\n  }\n\n  function frameLoop() {\n    var nextRefRect = getBoundingClientRect(reference);\n\n    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {\n      update();\n    }\n\n    prevRefRect = nextRefRect;\n    frameId = requestAnimationFrame(frameLoop);\n  }\n\n  update();\n  return function () {\n    var _resizeObserver2;\n\n    ancestors.forEach(function (ancestor) {\n      ancestorScroll && ancestor.removeEventListener('scroll', update);\n      ancestorResize && ancestor.removeEventListener('resize', update);\n    });\n    cleanupIo == null || cleanupIo();\n    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();\n    resizeObserver = null;\n\n    if (animationFrame) {\n      cancelAnimationFrame(frameId);\n    }\n  };\n}\n/**\n * Resolves with an object of overflow side offsets that determine how much the\n * element is overflowing a given clipping boundary on each side.\n * - positive = overflowing the boundary by that number of pixels\n * - negative = how many pixels left before it will overflow\n * - 0 = lies flush with the boundary\n * @see https://floating-ui.com/docs/detectOverflow\n */\n\n\nvar detectOverflow = detectOverflow$1;\n/**\n * Modifies the placement by translating the floating element along the\n * specified axes.\n * A number (shorthand for `mainAxis` or distance), or an axes configuration\n * object may be passed.\n * @see https://floating-ui.com/docs/offset\n */\n\nvar offset = offset$1;\n/**\n * Optimizes the visibility of the floating element by choosing the placement\n * that has the most space available automatically, without needing to specify a\n * preferred placement. Alternative to `flip`.\n * @see https://floating-ui.com/docs/autoPlacement\n */\n\nvar autoPlacement = autoPlacement$1;\n/**\n * Optimizes the visibility of the floating element by shifting it in order to\n * keep it in view when it will overflow the clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */\n\nvar shift = shift$1;\n/**\n * Optimizes the visibility of the floating element by flipping the `placement`\n * in order to keep it in view when the preferred placement(s) will overflow the\n * clipping boundary. Alternative to `autoPlacement`.\n * @see https://floating-ui.com/docs/flip\n */\n\nvar flip = flip$1;\n/**\n * Provides data that allows you to change the size of the floating element —\n * for instance, prevent it from overflowing the clipping boundary or match the\n * width of the reference element.\n * @see https://floating-ui.com/docs/size\n */\n\nvar size = size$1;\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */\n\nvar hide = hide$1;\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */\n\nvar arrow = arrow$1;\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */\n\nvar inline = inline$1;\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */\n\nvar limitShift = limitShift$1;\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a given reference element.\n */\n\nvar computePosition = function computePosition(reference, floating, options) {\n  // This caches the expensive `getClippingElementAncestors` function so that\n  // multiple lifecycle resets re-use the same result. It only lives for a\n  // single call. If other functions become expensive, we can add them as well.\n  var cache = new Map();\n\n  var mergedOptions = _objectSpread({\n    platform: platform\n  }, options);\n\n  var platformWithCache = _objectSpread({}, mergedOptions.platform, {\n    _c: cache\n  });\n\n  return computePosition$1(reference, floating, _objectSpread({}, mergedOptions, {\n    platform: platformWithCache\n  }));\n};\n\nexport { arrow, autoPlacement, autoUpdate, computePosition, detectOverflow, flip, hide, inline, limitShift, offset, platform, shift, size };","map":null,"metadata":{},"sourceType":"module"}